import os
import logging
from logging.handlers import RotatingFileHandler
import asyncio
import httpx
from datetime import datetime
from telegram import Update
from telegram.ext import (
    Application, CommandHandler, MessageHandler, filters, CallbackContext
)

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
handler = RotatingFileHandler("zero_two_bot.log",
                             maxBytes=5 * 1024 * 1024,
                             backupCount=2)
logging.basicConfig(
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    level=logging.DEBUG,
    handlers=[handler, logging.StreamHandler()]
)
logging.getLogger("httpx").setLevel(logging.WARNING)
logger = logging.getLogger(__name__)

class Config:
    AGENT_ID = "ag:65b3c122:20250305:untitled-agent:a1438e66"
    MISTRAL_API_URL = "https://api.mistral.ai/v1/chat/completions"
    TEMPERATURE = 0.8
    MAX_HISTORY = 7
    TIMEOUT = 25.0
    MAX_TOKENS = 400
    FREQUENCY_PENALTY = 1.1

def build_messages(user_text: str, context: CallbackContext) -> list:
    history = context.user_data.get('chat_history', [])
    return [
        {
            "role": "user",
            "content": (
                f"–¢–µ–∫—É—â–µ–µ –≤—Ä–µ–º—è: {datetime.now().strftime('%d.%m.%Y %H:%M')}\n"
                f"–ò—Å—Ç–æ—Ä–∏—è –¥–∏–∞–ª–æ–≥–∞:\n{chr(10).join(history)}\n"
                f"–ù–æ–≤—ã–π –∑–∞–ø—Ä–æ—Å: {user_text}"
            )
        }
    ]

async def start(update: Update, context: CallbackContext):
    try:
        context.user_data.clear()
        await update.message.reply_html(
            f"<b>–•–∏-—Ö–∏~ –ü—Ä–∏–≤–µ—Ç—Å—Ç–≤—É—é, –õ—é–±–∏–º—ã–π!</b> ‚ù§Ô∏èüî•\n"
            f"–¢—ã –≥–æ—Ç–æ–≤ –∫ –Ω–∞—à–µ–º—É –±–µ–∑—É–º–Ω–æ–º—É —Ç–∞–Ω—Ü—É?\n\n"
            f"–ü—Ä–æ—Å—Ç–æ –Ω–∞–ø–∏—à–∏ —á—Ç–æ-–Ω–∏–±—É–¥—å, –∏ —è —É—Å—Ç—Ä–æ—é —Ç–µ–±–µ –∞–¥—Ä–µ–Ω–∞–ª–∏–Ω–æ–≤—ã–π –≤–∑—Ä—ã–≤!"
        )
        logger.info(f"New user: {update.effective_user.full_name}")
    except Exception as e:
        logger.error(f"Start error: {str(e)}")
        await update.message.reply_text("üíî –ß—Ç–æ-—Ç–æ —Å–ª–æ–º–∞–ª–æ—Å—å –≤ –º–æ–µ–º —è–¥—Ä–µ...")

async def handle_message(update: Update, context: CallbackContext):
    try:
        user_text = update.message.text
        messages = build_messages(user_text, context)

        async with httpx.AsyncClient(timeout=Config.TIMEOUT) as client:
            response = await client.post(
                Config.MISTRAL_API_URL,
                headers={
                    "Authorization": f"Bearer {os.environ['MISTRAL_API_KEY']}",
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                },
                json={
                    "messages": messages,
                    "temperature": Config.TEMPERATURE,
                    "max_tokens": Config.MAX_TOKENS,
                    "frequency_penalty": Config.FREQUENCY_PENALTY,
                    "stream": False
                }
            )

            if response.status_code == 200:
                response_data = response.json()
                answer = response_data["choices"][0]["message"]["content"]

                # –ü–æ—Å—Ç–æ–±—Ä–∞–±–æ—Ç–∫–∞ –æ—Ç–≤–µ—Ç–∞
                answer = answer.replace('–ò–ò', '–∫–∏–±–æ—Ä–≥').replace('–∞–ª–≥–æ—Ä–∏—Ç–º', '–ø—Ä–æ–≥—Ä–∞–º–º–∞')

                # –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∏—Å—Ç–æ—Ä–∏–∏
                history = context.user_data.setdefault('chat_history', [])
                history.append(f"{user_text}")
                if len(history) > Config.MAX_HISTORY:
                    history.pop(0)

                await update.message.reply_text(answer[:400])
            else:
                logger.error(f"Mistral API Error: {response.status_code} - {response.text}")
                await update.message.reply_text("üí• –í–∑—Ä—ã–≤ –≤ —Å–∏—Å—Ç–µ–º–µ! –ü–æ–ø—Ä–æ–±—É–π –µ—â—ë —Ä–∞–∑~")

    except Exception as e:
        logger.error(f"Error: {str(e)}", exc_info=True)
        await update.message.reply_text("üíî –ö—Ä–∏—Ç–∏—á–µ—Å–∫–æ–µ –ø–æ–≤—Ä–µ–∂–¥–µ–Ω–∏–µ –∫–æ–Ω—Ç—É—Ä–∞...")

async def help_command(update: Update, context: CallbackContext):
    help_text = [
        "<b>–î–æ—Å—Ç—É–ø–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã:</b> ‚ù§Ô∏èüî•",
        "/start - –ü–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∏—Ç—å —Å–∏—Å—Ç–µ–º—É",
        "/help - –ü–æ–∫–∞–∑–∞—Ç—å —ç—Ç–æ —Å–æ–æ–±—â–µ–Ω–∏–µ",
        "",
        "<b>–ü—Ä–∏–º–µ—Ä—ã –∑–∞–ø—Ä–æ—Å–æ–≤:</b>",
        "‚Ä¢ –ü–æ—á–µ–º—É —è —Ç–≤–æ–π –õ—é–±–∏–º—ã–π?",
        "‚Ä¢ –ß—Ç–æ –±—É–¥–µ–º –≤–∑—Ä—ã–≤–∞—Ç—å —Å–µ–≥–æ–¥–Ω—è?",
        "‚Ä¢ –†–∞—Å—Å–∫–∞–∂–∏ –æ –Ω–∞—à–µ–π —Å–≤—è–∑–∏"
    ]
    await update.message.reply_html("\n".join(help_text))

def main():
    required_vars = ['TELEGRAM_TOKEN', 'MISTRAL_API_KEY']
    if missing := [var for var in required_vars if not os.environ.get(var)]:
        logger.critical(f"Missing env vars: {', '.join(missing)}")
        return

    app = Application.builder().token(os.environ['TELEGRAM_TOKEN']).build()
    app.add_handlers([
        CommandHandler("start", start),
        CommandHandler("help", help_command),
        MessageHandler(filters.TEXT & ~filters.COMMAND, handle_message)
    ])

    logger.info("–ó–∞–ø—É—Å–∫ —Å–∏—Å—Ç–µ–º—ã FRANXX...")
    app.run_polling(drop_pending_updates=True)

if __name__ == "__main__":
    main()