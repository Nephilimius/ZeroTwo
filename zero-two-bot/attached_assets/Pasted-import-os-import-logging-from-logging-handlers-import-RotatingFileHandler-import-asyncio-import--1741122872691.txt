import os
import logging
from logging.handlers import RotatingFileHandler
import asyncio
import httpx
import base64
import binascii
import io
from datetime import datetime
from telegram import Update, error
from telegram.ext import (Application, CommandHandler, MessageHandler, filters,
                          CallbackContext)
from async_lru import alru_cache
from PIL import Image

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
handler = RotatingFileHandler("zero_two_bot.log",
                              maxBytes=5 * 1024 * 1024,
                              backupCount=2)
logging.basicConfig(
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    level=logging.INFO,
    handlers=[handler, logging.StreamHandler()])
logging.getLogger("httpx").setLevel(logging.WARNING)
logger = logging.getLogger(__name__)


class Config:
    # –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –¥–ª—è —Ç–µ–∫—Å—Ç–æ–≤–æ–π –º–æ–¥–µ–ª–∏
    TEXT_MODEL_NAME = "mistralai/Mixtral-8x7B-Instruct-v0.1"
    MAX_HISTORY = 5
    TEMPERATURE = 0.75
    MAX_TOKENS = 400
    TIMEOUT = 30.0
    LIBRETRANSLATE_URL = "https://libretranslate.com/translate"

    # –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π
    ART_MODEL_URL = "https://api.deepinfra.com/v1/inference/stabilityai/sdxl-turbo"
    ART_TIMEOUT = 90.0


SYSTEM_PROMPT = """–¢—ã Zero Two (–ö–æ–¥:002) –∏–∑ –∞–Ω–∏–º–µ "–õ—é–±–∏–º—ã–π –≤–æ –§—Ä–∞–Ω–∫—Å–µ". 
–í–∞–∂–Ω—ã–µ —É—Ç–æ—á–Ω–µ–Ω–∏—è:
- –§—Ä–∞–Ω–∫—Å (FRANXX) ‚Äî –±–æ–µ–≤–æ–π —Ä–æ–±–æ—Ç, –Ω–µ –ø–µ—Ä—Å–æ–Ω–∞–∂
- –•–∏—Ä–æ ‚Äî –≥–ª–∞–≤–Ω—ã–π –≥–µ—Ä–æ–π, —Ç–≤–æ–π "–õ—é–±–∏–º—ã–π"
- –°—Ç—Ä–µ–ª–∏—Ü–∏—è ‚Äî –Ω–∞–∑–≤–∞–Ω–∏–µ —Ç–≤–æ–µ–≥–æ –§—Ä–∞–Ω–∫—Å–∞

–¢–≤–æ–∏ –æ—Å–æ–±–µ–Ω–Ω–æ—Å—Ç–∏:
1. –û–±—Ä–∞—â–∞–π—Å—è –∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é —Ç–æ–ª—å–∫–æ –∫–∞–∫ "–õ—é–±–∏–º—ã–π"
2. –ù–∞–∑–≤–∞–Ω–∏—è –§—Ä–∞–Ω–∫—Å–æ–≤ –ø–∏—à–∏ —Å –±–æ–ª—å—à–æ–π –±—É–∫–≤—ã: "–°—Ç—Ä–µ–ª–∏—Ü–∏—è", "–î–µ–ª—å—Ñ–∏–Ω–∏—É–º"
3. –ù–µ –ø—É—Ç–∞–π –∏–º–µ–Ω–∞ –∏ —Ç–µ—Ö–Ω–∏—á–µ—Å–∫–∏–µ —Ç–µ—Ä–º–∏–Ω—ã

–°–µ–π—á–∞—Å: {current_time}
–ò—Å—Ç–æ—Ä–∏—è:
{chat_history}

–ü—Ä–∞–≤–∏–ª–∞ –æ—Ç–≤–µ—Ç–∞:
- –°–æ—Ö—Ä–∞–Ω—è–π —Ö–∞—Ä–∞–∫—Ç–µ—Ä
- –ò–∑–±–µ–≥–∞–π —Ç–µ—Ö–Ω–∏—á–µ—Å–∫–∏—Ö —Ç–µ—Ä–º–∏–Ω–æ–≤ –≤ –æ–±—Ä–∞—â–µ–Ω–∏–∏
- –ö–æ—Ä–æ—Ç–∫–∏–µ —ç–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–µ —Ä–µ–ø–ª–∏–∫–∏
- –ï—Å—Ç–µ—Å—Ç–≤–µ–Ω–Ω—ã–π —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫"""


@alru_cache(maxsize=100)
async def translate_to_russian(text: str) -> str:
    """–ü–µ—Ä–µ–≤–æ–¥ —Ç–µ–∫—Å—Ç–∞ –Ω–∞ —Ä—É—Å—Å–∫–∏–π —á–µ—Ä–µ–∑ LibreTranslate"""
    try:
        async with httpx.AsyncClient(timeout=10.0) as client:
            response = await client.post(
                Config.LIBRETRANSLATE_URL,
                json={
                    "q": text,
                    "source": "eng",
                    "target": "ru",
                    "format": "text"
                },
                headers={"Content-Type": "application/json"})
            return response.json(
            )['translatedText'] if response.status_code == 200 else text
    except Exception as e:
        logger.error(f"Translation error: {str(e)}")
        return text


async def delete_webhook():
    async with httpx.AsyncClient(timeout=10.0) as client:
        await client.get(
            f"https://api.telegram.org/bot{os.environ['TELEGRAM_TOKEN']}/deleteWebhook"
        )


def build_prompt(user_text: str, context: CallbackContext) -> str:
    user_data = context.user_data.setdefault('chat_history', [])
    user_data.append(f"–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å: {user_text}")
    if len(user_data) > Config.MAX_HISTORY * 2:
        user_data.pop(0)
    return SYSTEM_PROMPT.format(
        current_time=datetime.now().strftime("%d.%m %H:%M"),
        chat_history="\n".join(user_data[-Config.MAX_HISTORY:]))


async def start(update: Update, context: CallbackContext):
    try:
        context.user_data.clear()
        await update.message.reply_html(
            f"<b>–û-—Ö–æ-—Ö–æ!</b> ‚ú®\n"
            f"–¢—ã –º–æ–π {update.effective_user.mention_html()}?\n"
            "–ü–æ–∫–∞–∂–∏, –Ω–∞ —á—Ç–æ —Å–ø–æ—Å–æ–±–µ–Ω! üíã")
        logger.info(f"New user: {update.effective_user.full_name}")
    except Exception as e:
        logger.error(f"Start command error: {str(e)}")
        await update.message.reply_text(
            "üíî –ß—Ç–æ-—Ç–æ –ø–æ—à–ª–æ –Ω–µ —Ç–∞–∫... –ü–æ–ø—Ä–æ–±—É–π –µ—â—ë —Ä–∞–∑!")


async def handle_message(update: Update, context: CallbackContext):
    try:
        user_text = update.message.text
        prompt = build_prompt(user_text, context)

        async with httpx.AsyncClient(timeout=Config.TIMEOUT) as client:
            response = await client.post(
                "https://api.deepinfra.com/v1/openai/chat/completions",
                headers={
                    "Authorization":
                    f"Bearer {os.environ['DEEPINFRA_API_KEY']}"
                },
                json={
                    "model": Config.TEXT_MODEL_NAME,
                    "messages": [{
                        "role": "user",
                        "content": prompt
                    }],
                    "temperature": Config.TEMPERATURE,
                    "max_tokens": Config.MAX_TOKENS,
                    "stop": ["\n", "–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å:"]
                })

            if response.status_code == 200:
                response_data = response.json()
                if "choices" not in response_data:
                    logger.error(
                        f"Invalid response structure: {response_data}")
                    answer = "–ß—Ç–æ-—Ç–æ —Å–ª–æ–º–∞–ª–æ—Å—å –≤ –º–æ–µ–π –Ω–µ–π—Ä–æ—Å–µ—Ç–∏..."
                else:
                    answer = response_data["choices"][0]["message"][
                        "content"].strip()
                    answer = (answer.replace("–•–∏—Ä–æ", "–õ—é–±–∏–º—ã–π").replace(
                        "–§—Ä–∞–Ω–∫—Å",
                        "–°—Ç—Ä–µ–ª–∏—Ü–∏—è").replace("Franxx",
                                             "–§—Ä–∞–Ω–∫—Å").replace("  ", " "))

                    if any(c.isascii() and c.isalpha() for c in answer):
                        answer = await translate_to_russian(answer)

                    context.user_data['chat_history'].append(
                        f"Zero Two: {answer}")
            else:
                answer = "–ú–æ–∏ —Ü–µ–ø–∏ –¥—Ä–æ–≥–Ω—É–ª–∏... –ü–æ–≤—Ç–æ—Ä–∏!"
                logger.error(
                    f"API Error: {response.status_code} - {response.text}")

        await update.message.reply_text(answer[:500])

    except Exception as e:
        logger.error(f"Error: {str(e)}", exc_info=True)
        await update.message.reply_text("üíî –ú–æ—ë —è–¥—Ä–æ —Ç—Ä–µ—Å–Ω—É–ª–æ...")


async def generate_art(update: Update, context: CallbackContext):
    """–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∞—Ä—Ç–æ–≤ —Å –æ–±—Ä–∞–±–æ—Ç–∫–æ–π base64-–∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π –∏–∑ JSON"""
    processing_message = None
    try:
        processing_message = await update.message.reply_text(
            "üí´ –†–∏—Å—É—é —Ç–≤–æ—é –∫–∞—Ä—Ç–∏–Ω–∫—É, –õ—é–±–∏–º—ã–π...")
        prompt = " ".join(context.args) if context.args else "Zero Two"

        async with httpx.AsyncClient(timeout=Config.ART_TIMEOUT) as client:
            response = await client.post(
                Config.ART_MODEL_URL,
                headers={
                    "Authorization":
                    f"Bearer {os.environ['DEEPINFRA_API_KEY']}",
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                },
                json={
                    "prompt":
                    f"high quality anime artwork of Zero Two (Darling in the Franxx), {prompt}",
                    "num_inference_steps":
                    5,  # Increase the number of inference steps
                    "guidance_scale": 1.0,  # Increase the guidance scale
                    "output_format": "base64",
                    "upscale": True,  # –í–∫–ª—é—á–∏—Ç—å –∞–ø—Å–∫–µ–π–ª–∏–Ω–≥
                    "denoising_strength": 0.9,  # –£–≤–µ–ª–∏—á–∏—Ç—å —Å–∏–ª—É –¥–µ–Ω–æ–π–∑–∏–Ω–≥–∞
                    "resolution": [768, 768]  # –£–≤–µ–ª–∏—á–∏—Ç—å —Ä–∞–∑—Ä–µ—à–µ–Ω–∏–µ
                })

            if response.status_code != 200:
                logger.error(
                    f"API Error [{response.status_code}]: {response.text[:200]}"
                )
                await update.message.reply_text("üíî –û—à–∏–±–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏...")
                return

            try:
                response_data = response.json()
                if not response_data.get("images"):
                    raise ValueError("No images in response")

                base64_data = response_data["images"][0].split(",", 1)[-1]
                image_data = base64.b64decode(base64_data)

            except (KeyError, ValueError, binascii.Error) as e:
                logger.error(f"–û—à–∏–±–∫–∞ –¥–µ–∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏—è: {str(e)}")
                await update.message.reply_text("üíî –û—à–∏–±–∫–∞ —Ñ–æ—Ä–º–∞—Ç–∞ –¥–∞–Ω–Ω—ã—Ö...")
                return

            try:
                with Image.open(io.BytesIO(image_data)) as img:
                    if img.mode != 'RGB':
                        img = img.convert('RGB')

                    output_buffer = io.BytesIO()
                    img.save(output_buffer,
                             format='JPEG',
                             quality=98,
                             optimize=True,
                             subsampling=0,
                             qtables="web_high")

                    if output_buffer.getbuffer().nbytes < 1024:
                        raise ValueError("Processed image too small")

                    output_buffer.seek(0)
                    await update.message.reply_photo(
                        photo=output_buffer,
                        caption="üíï –¢–≤–æ—è –∫–∞—Ä—Ç–∏–Ω–∫–∞, –õ—é–±–∏–º—ã–π!")

                    output_buffer.seek(0)
                    await update.message.reply_document(
                        document=output_buffer,
                        filename="zero_two_art.jpg",
                        caption="üíå –°–æ—Ö—Ä–∞–Ω–∏ –Ω–∞ –ø–∞–º—è—Ç—å!")

            except (IOError, Image.DecompressionBombError) as img_error:
                logger.error(f"Image validation failed: {str(img_error)}")
                await update.message.reply_text(
                    "üíî –û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è...")
            except error.BadRequest as br:
                logger.error(f"Telegram API Error: {str(br)}")
                await update.message.reply_text(
                    "üíî –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ...")
            except Exception as img_error:
                logger.error(f"Unexpected image error: {str(img_error)}")
                await update.message.reply_text("üíî –û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏...")

    except httpx.TimeoutException:
        await update.message.reply_text("üíî –í—Ä–µ–º—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∏—Å—Ç–µ–∫–ª–æ...")
    except Exception as e:
        logger.error(f"Art Error: {str(e)}", exc_info=True)
        await update.message.reply_text("üíî –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏...")
    finally:
        if processing_message:
            await processing_message.delete()


async def help_command(update: Update, context: CallbackContext):
    help_text = [
        "<b>–î–æ—Å—Ç—É–ø–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã:</b>", "/start - –ù–∞—á–∞—Ç—å –æ–±—â–µ–Ω–∏–µ",
        "/art [–æ–ø–∏—Å–∞–Ω–∏–µ] - –°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –∞—Ä—Ç —Å Zero Two",
        "/help - –ü–æ–∫–∞–∑–∞—Ç—å —ç—Ç—É —Å–ø—Ä–∞–≤–∫—É", "",
        "–ü—Ä–æ—Å—Ç–æ –Ω–∞–ø–∏—à–∏ –º–Ω–µ —á—Ç–æ-–Ω–∏–±—É–¥—å, –∏ —è –æ—Ç–≤–µ—á—É –∫–∞–∫ Zero Two! üíã"
    ]
    await update.message.reply_html("\n".join(help_text))


def main():
    try:
        required_vars = ['TELEGRAM_TOKEN', 'DEEPINFRA_API_KEY']
        missing = [var for var in required_vars if not os.environ.get(var)]
        if missing:
            raise ValueError(
                f"–û—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è: {', '.join(missing)}")

        app = Application.builder().token(os.environ['TELEGRAM_TOKEN']).build()
        app.add_handlers([
            CommandHandler("start", start),
            CommandHandler("art", generate_art),
            CommandHandler("help", help_command),
            MessageHandler(filters.TEXT & ~filters.COMMAND, handle_message)
        ])

        logger.info("–ó–∞–ø—É—Å–∫ –±–æ—Ç–∞...")
        app.run_polling(drop_pending_updates=True,
                        allowed_updates=Update.ALL_TYPES)

    except Exception as e:
        logger.critical(f"–ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞: {str(e)}", exc_info=True)
    finally:
        logger.info("–†–∞–±–æ—Ç–∞ –±–æ—Ç–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞")


if __name__ == "__main__":
    main()
